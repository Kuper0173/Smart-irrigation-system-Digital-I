/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module Prueba2 (
  input HUMEDAD,
  input AGUA,
  input BOMBA,
  input ON,
  input [2:0] TEMP,
  input CLK,
  output ANDP,
  output [7:0] SMUX,
  output [7:0] OUTF,
  output OUT
);
  wire ANDP_temp;
  wire [7:0] SMUX_temp;
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  assign ANDP_temp = (HUMEDAD & AGUA & BOMBA & ON);
  Mux_8x1_NBits #(
    .Bits(8)
  )
  Mux_8x1_NBits_i0 (
    .sel( TEMP ),
    .in_0( 8'b11110 ),
    .in_1( 8'b101000 ),
    .in_2( 8'b110010 ),
    .in_3( 8'b111100 ),
    .in_4( 8'b1000110 ),
    .in_5( 8'b1010000 ),
    .in_6( 8'b1011010 ),
    .in_7( 8'b1011010 ),
    .out( SMUX_temp )
  );
  // FFD1
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( ANDP_temp ),
    .C( CLK ),
    .\~Q ( s2 )
  );
  assign s5 = ~ ANDP_temp;
  assign s0 = (ANDP_temp & s2);
  // CONT
  DIG_CounterPreset #(
    .Bits(8),
    .maxValue(0)
  )
  DIG_CounterPreset_i2 (
    .en( ANDP_temp ),
    .C( CLK ),
    .dir( 1'b1 ),
    .in( SMUX_temp ),
    .ld( s0 ),
    .clr( 1'b0 ),
    .out( OUTF ),
    .ovf( s1 )
  );
  assign s4 = (s3 | (ANDP_temp & s1));
  // FFD2
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( s4 ),
    .C( CLK ),
    .Clr( s5 ),
    .Q( s3 )
  );
  assign OUT = (ANDP_temp & ~ s3);
  assign ANDP = ANDP_temp;
  assign SMUX = SMUX_temp;
endmodule
